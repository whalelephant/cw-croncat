{
  "contract_name": "croncat-agents",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "croncat_manager_key",
      "croncat_tasks_key"
    ],
    "properties": {
      "agent_nomination_duration": {
        "description": "Sets the amount of time opportunity for a pending agent to become active. If there is a pending queue, the longer a pending agent waits, the more pending agents can potentially become active based on this nomination window. This duration doesn't block the already nominated agent from becoming active, it only opens the door for more to become active. If a pending agent is nominated, then is lazy and beat by another agent, they get removed from pending queue and must register again.",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint16",
        "minimum": 0.0
      },
      "croncat_manager_key": {
        "description": "Name of the key for raw querying Manager address from the factory",
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            },
            "maxItems": 2,
            "minItems": 2
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "croncat_tasks_key": {
        "description": "Name of the key for raw querying Tasks address from the factory",
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            },
            "maxItems": 2,
            "minItems": 2
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "min_coin_for_agent_registration": {
        "description": "The required amount needed to actually execute a few tasks before withdraw profits. This helps make sure agent wont get stuck out the gate",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      },
      "min_tasks_per_agent": {
        "description": "The ratio used to calculate active agents/tasks. Example: \"3\", requires there are 4 tasks before letting in another agent to become active. (3 tasks for agent 1, 1 task for agent 2)",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      },
      "owner_addr": {
        "description": "Address of the contract owner, defaults to the sender",
        "type": [
          "string",
          "null"
        ]
      },
      "version": {
        "description": "CW2 Version provided by factory",
        "type": [
          "string",
          "null"
        ]
      }
    },
    "additionalProperties": false
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "register_agent"
        ],
        "properties": {
          "register_agent": {
            "type": "object",
            "properties": {
              "payable_account_id": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_agent"
        ],
        "properties": {
          "update_agent": {
            "type": "object",
            "required": [
              "payable_account_id"
            ],
            "properties": {
              "payable_account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "check_in_agent"
        ],
        "properties": {
          "check_in_agent": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unregister_agent"
        ],
        "properties": {
          "unregister_agent": {
            "type": "object",
            "properties": {
              "from_behind": {
                "type": [
                  "boolean",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "on_task_created"
        ],
        "properties": {
          "on_task_created": {
            "$ref": "#/definitions/AgentOnTaskCreated"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/definitions/UpdateConfig"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AgentOnTaskCreated": {
        "type": "object",
        "required": [
          "task_hash"
        ],
        "properties": {
          "task_hash": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "UpdateConfig": {
        "type": "object",
        "properties": {
          "agent_nomination_duration": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint16",
            "minimum": 0.0
          },
          "croncat_factory_addr": {
            "description": "Address of the factory contract",
            "type": [
              "string",
              "null"
            ]
          },
          "croncat_manager_key": {
            "description": "Name of the key for raw querying Manager address from the factory",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint8",
                  "minimum": 0.0
                },
                "maxItems": 2,
                "minItems": 2
              }
            ],
            "maxItems": 2,
            "minItems": 2
          },
          "croncat_tasks_key": {
            "description": "Name of the key for raw querying Tasks address from the factory",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint8",
                  "minimum": 0.0
                },
                "maxItems": 2,
                "minItems": 2
              }
            ],
            "maxItems": 2,
            "minItems": 2
          },
          "min_coins_for_agent_registration": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "min_tasks_per_agent": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "owner_addr": {
            "type": [
              "string",
              "null"
            ]
          },
          "paused": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "get_agent"
        ],
        "properties": {
          "get_agent": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_agent_ids"
        ],
        "properties": {
          "get_agent_ids": {
            "type": "object",
            "properties": {
              "from_index": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_agent_tasks"
        ],
        "properties": {
          "get_agent_tasks": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "type": "object",
      "required": [
        "agent_nomination_duration",
        "croncat_factory_addr",
        "croncat_manager_key",
        "croncat_tasks_key",
        "min_coins_for_agent_registration",
        "min_tasks_per_agent",
        "owner_addr",
        "paused"
      ],
      "properties": {
        "agent_nomination_duration": {
          "description": "The duration a prospective agent has to nominate themselves. When a task is created such that a new agent can join, The agent at the zeroth index of the pending agent queue has this time to nominate The agent at the first index has twice this time to nominate (which would remove the former agent from the pending queue) Value is in seconds",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "croncat_factory_addr": {
          "description": "Address of the factory contract",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "croncat_manager_key": {
          "description": "Name of the key for raw querying Manager address from the factory",
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "uint8",
                "minimum": 0.0
              },
              "maxItems": 2,
              "minItems": 2
            }
          ],
          "maxItems": 2,
          "minItems": 2
        },
        "croncat_tasks_key": {
          "description": "Name of the key for raw querying Tasks address from the factory",
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "uint8",
                "minimum": 0.0
              },
              "maxItems": 2,
              "minItems": 2
            }
          ],
          "maxItems": 2,
          "minItems": 2
        },
        "min_coins_for_agent_registration": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "min_tasks_per_agent": {
          "description": "Agent management The minimum number of tasks per agent Example: 10 Explanation: For every 1 agent, 10 tasks per slot are available. NOTE: Caveat, when there are odd number of tasks or agents, the overflow will be available to first-come, first-serve. This doesn't negate the possibility of a failed txn from race case choosing winner inside a block. NOTE: The overflow will be adjusted to be handled by sweeper in next implementation.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "owner_addr": {
          "$ref": "#/definitions/Addr"
        },
        "paused": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "get_agent": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_AgentResponse",
      "anyOf": [
        {
          "$ref": "#/definitions/AgentResponse"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AgentResponse": {
          "type": "object",
          "required": [
            "balance",
            "last_executed_slot",
            "payable_account_id",
            "register_start",
            "status"
          ],
          "properties": {
            "balance": {
              "$ref": "#/definitions/Uint128"
            },
            "last_executed_slot": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "payable_account_id": {
              "$ref": "#/definitions/Addr"
            },
            "register_start": {
              "$ref": "#/definitions/Timestamp"
            },
            "status": {
              "$ref": "#/definitions/AgentStatus"
            }
          },
          "additionalProperties": false
        },
        "AgentStatus": {
          "type": "string",
          "enum": [
            "active",
            "pending",
            "nominated"
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_agent_ids": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_GetAgentIdsResponse",
      "anyOf": [
        {
          "$ref": "#/definitions/GetAgentIdsResponse"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "GetAgentIdsResponse": {
          "type": "object",
          "required": [
            "active",
            "pending"
          ],
          "properties": {
            "active": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Addr"
              }
            },
            "pending": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Addr"
              }
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_agent_tasks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AgentTaskResponse",
      "type": "object",
      "required": [
        "num_block_tasks",
        "num_cron_tasks"
      ],
      "properties": {
        "num_block_tasks": {
          "$ref": "#/definitions/Uint64"
        },
        "num_cron_tasks": {
          "$ref": "#/definitions/Uint64"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
